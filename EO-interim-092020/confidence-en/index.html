<doctype HTML>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">

    <head>

        <link
            href="https://fonts.googleapis.com/css?family=Noto+Sans:400,400i,700,700i|Oswald:200,300,400,500,600,700&display=swap&subset=latin-ext"
            rel="stylesheet">
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" type="text/css" href="css/site.css">
        <script src="https://code.jquery.com/jquery-3.5.0.js"
            integrity="sha256-r/AaFHrszJtwpe+tHyNi/XCfMxYpbsRg2Uqn0x3s2zc=" crossorigin="anonymous"></script>
        <link href="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/css/select2.min.css" rel="stylesheet" />
        <script src="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/js/select2.min.js"></script>

        <script src="libs/d3.v4.min.js"></script>
        <script src="libs/d3.v4.jetpack.min.js"></script>
        <script src="libs/d3-scale-chromatic.v1.min.js"></script>
        <script src="libs/topojson.v1.min.js"></script>
        <script src="libs/d3-queue.v3.min.js"></script>
        <script src="libs/d3-annotation.js"></script>
         <link rel="icon" href="img/favicon.ico">
 
    </head>

    <body>
    <h1>OECD Economic Outlook September 2020</h1>
    <h2>World GDP, index 2019-Q4=100</h2>
    <div id="player"><img id="Play" src="img/triangle-right.svg" alt="Play button"> Play the story</div>
    <img id="Share" src="img/share.svg" alt="share">
    <div id="switchHolder">
        <id id="sliderText">Compare with June forecasts:</id>
        <label class="switch">
            <input id="switchID" type="checkbox" >
            <span class="slider round"></span>
        </label>
    </div>
    <br/>
    <div id="scenario" alt=""></div>
    <div id="explainer"></div>
    <div id="source" class="source">Source: <a class="source" href="https://doi.org/10.1787/eo-data-en" target="_blank">OECD (2020), "OECD Economic Outlook, Interim Report September 2020", OECD Economic Outlook: Statistics and Projections (database)</a>. </div>
    <div id="shareLink">
        <div id="shutterholdertracker">
            <img id="shuttershare" src="img/cross.svg">
            <div id="trackersText">
                <b>Copy link:</b><Br />
                <span>https://oecd.github.io/oecd-eco-outlook/EO-interim-092020/confidence-en/</span><Br />
                <b>Embed link:</b><Br />
                <textarea
                    readonly><iframe src="https://oecd.github.io/oecd-eco-outlook/EO-interim-092020/confidence-en//" width="100%" height="500px" style="border:none;"></iframe></textarea>
    
            </div>
        </div>
    </div>
    <script type="text/javascript">

        var startChart = "2018-Q1";
        var startForecast = "2019-Q4";
            var startForecast2 = "2020-Q3";
        var dashedStartForecast = "2020-Q3";
        var dashedStartpreviousForecast = "2020-Q1";
        var annotationMark=[];


    var allScenario;
    

    var divMap = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0); 
    var color = ["#8EA4B1", "#f63ba8","#ff9cfb", "#c777c6", "#37003c",  "#a154a1", "#719E24"];

    var margin = { top: 30, right: 50, bottom: 30, left: 40 };

    var mapRatio = 8 / 20;
    var width,lagText,height;

    if(document.getElementById("scenario").offsetWidth - margin.left - margin.right > 1140-margin.right - margin.left)
        width = 1140 - margin.right - margin.left;
    else
        width = document.getElementById("scenario").offsetWidth - margin.left - margin.right;

    if (width > 650){
            height = 290;//height = width * mapRatio;
            lagText = 10;

    }
    else{
        height = 290;//height = width;
        lagText = 1;
    }


    var urls = {
        scenario: "data/data.tsv"
        
    };

    d3.queue()
        .defer(d3.tsv, urls.scenario)
        .await(render);



    var scenarioSVG = d3.select("#scenario").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");

    // Add X axis --> it is a date format
    var x = d3.scaleLinear()
        .range([0, width]);

    function dateParser(d) {
        var splitted = d.split('-');
        var quarterEndMonth = splitted[1].charAt(1) * 3;
        var quarterStartMonth = quarterEndMonth - 3;

        return d3.timeParse('%m-%Y')(quarterStartMonth + '-' + splitted[0]);
    }


    var bisectDate = d3.bisector(function (d) { return dateParser(d.TIME); }).left;
    //Add Y axis
    var y = d3.scaleLinear() //or scaleLog
        .range([height, 0]);



    function tweenDash() {
        var l = this.getTotalLength(),
            i = d3.interpolateString("0," + l, l + "," + l);
        return function (t) { return i(t); };
    }

    function render(err, scenarioData) {
        allScenario = scenarioData;
        annotationMark= scenarioData.filter(function (d) { return d.TIME == "2021-Q1" ; });
        annotationMark2019 = scenarioData.filter(function (d) { return  d.TIME == "2020-Q1"; });
        annotationMarkPosition = scenarioData.filter(function (d) { return d.TIME == "2020-Q3"; });

        renderChart();


    }
     function updateChart() {
        document.getElementById("player").style.display = "none";
        scenarioSVG.selectAll("*").remove()

        x.domain(d3.extent(allScenario, function (d) { return dateParser(d.TIME); }))
        y.domain([d3.min(allScenario, function (d) { return d3.min([parseFloat(d.forecast2019), parseFloat(d.singleHit), parseFloat(d.doubleHit), parseFloat(d.currentScenario), parseFloat(d.upsideScenario), parseFloat(d.downsideScenario)]); }), d3.max(allScenario, function (d) { return d3.max([parseFloat(d.forecast2019), parseFloat(d.singleHit), parseFloat(d.doubleHit), parseFloat(d.currentScenario), parseFloat(d.upsideScenario), parseFloat(d.downsideScenario)]); })])



        scenarioSVG
            .append("g")
            .attr("class", "axisContext")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x).ticks(6)
                .tickFormat(function (x) {
                    // get the milliseconds since Epoch for the date
                    var milli = (x + 7884000000);

                    // calculate new date 10 seconds earlier. Could be one second, 
                    // but I like a little buffer for my neuroses
                    var vanilli = new Date(milli);

                    // calculate the month (0-11) based on the new date
                    var mon = vanilli.getMonth();
                    var yr = vanilli.getFullYear();

                    // return appropriate quarter for that month
                    if (mon <= 2) {
                        return yr + "-Q1";
                    } else if (mon <= 5) {
                        return yr + "-Q2";
                    } else if (mon <= 8) {
                        return yr + "-Q3";
                    } else {
                        return yr + "-Q4";
                    }
                }));

        scenarioSVG.append("g")
            .attr("class", "axisContext")
            .call(d3.axisLeft(y).tickFormat(function (d) {
                return y.tickFormat(10, d3.format(".0f"))(d)
            }).tickSize(-(width)));


        // Draw the line
        scenarioSVG
            .append("path")
            .attr("fill", "none"/*"#8DCD79"*/)
            .attr("stroke", function (d) { return color[0] })
            .attr("stroke-width", "5px")
           // .attr("opacity", function () { if (k == 0) return 0.1; else return 1; })
            .attr("class", "lineContext")
            //.attr("id", function (d) { return "doubleHit" + i; })
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.forecast2019)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) <= dateParser(startForecast); }))
            })
            .transition()
            .duration(0)
            .attrTween("stroke-dasharray", tweenDash)
            .on("end", drawforecast)

        //document.getElementById('explainer').innerHTML = "This is the total woking hours losts in the 3 first months of the global financial crisis"
        


        // Draw forecast
        function drawforecast(){             
        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke", function (d) { return color[0] })
            .attr("stroke-width", "5px")
            .attr("opacity",0.5)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.forecast2019)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
            })
            .transition()
            .duration(8000)
            .attrTween("stroke-dasharray", tweenDash)

            scenarioSVG
                .append("path")
                .attr("fill", "none")
                .attr("stroke-width", "5px")
                .attr("class","forecast")
                .transition().delay(7500)
                .attr("d", function (d) {
                    return d3.line()//area
                        .x(function (d) { return x(dateParser(d.TIME)); })
                        // .y0(y(0))
                        .y(function (d) { return y(parseFloat(d.forecast2019)); })
                        (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
                })
                .on("end", drawCurrentProj)

   
            document.getElementById('explainer').innerHTML = "This is the evolution of the world GDP as the OECD anticipated it back in November 2019. The Covid-19 crisis has changed everything";
         

        }

        function drawCurrentProj(){
            //Draw the uncertainty area/invisible at first made visible later
            /*scenarioSVG
                .append("path")
                .attr("class", "forecast")
                .attr("id", "uncertaintyArea")
                .attr("fill", color[2])
                .attr("stroke-width", "0px")
                .attr("opacity",0)
                .attr("d", function (d) {
                    return d3.area()
                        .x(function (d) { return x(dateParser(d.TIME)); })
                        .y0(function (d) { return y(parseFloat(d.downsideScenario)); })
                        .y1(function (d) { return y(parseFloat(d.upsideScenario)); })
                        (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartForecast); }))
                })*/

            scenarioSVG
                .append("path")
                .attr("fill", "none")
                .attr("stroke", function (d) { return color[1] })
                .attr("stroke-width", "5px")
                .attr("d", function (d) {
                    return d3.line()//area
                        .x(function (d) { return x(dateParser(d.TIME)); })
                        // .y0(y(0))
                        .y(function (d) { return y(parseFloat(d.currentProjection)); })
                        (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
                })
                .transition()
                .duration(7000)
                .attrTween("stroke-dasharray", tweenDash)

            scenarioSVG
                .append("path")
                .attr("fill", "none")
                .attr("stroke-width", "5px")
                .attr("class", "forecast")
                .transition().delay(6500)
                .attr("d", function (d) {
                    return d3.line()//area
                        .x(function (d) { return x(dateParser(d.TIME)); })
                        // .y0(y(0))
                        .y(function (d) { return y(parseFloat(d.currentProjection)); })
                        (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartForecast); }))
                })
                .on("end", drawDownSideScenario)


            document.getElementById('explainer').innerHTML = "This pink line shows how world GDP has evolved following the COVID-crisis and how the OECD anticipates it growing.";
            

        } 


        function drawDownSideScenario(){

            scenarioSVG
                .append("path")
                .attr("fill", "none")
                .attr("stroke", function (d) { return color[2] })
                .attr("stroke-width", "3px")
                .attr("d", function (d) {
                    return d3.line()//area
                        .x(function (d) { return x(dateParser(d.TIME)); })
                        // .y0(y(0))
                        .y(function (d) { return y(parseFloat(d.downsideScenario)); })
                        (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast2); }))
                })
                .transition()
                .duration(8000)
                .attrTween("stroke-dasharray", tweenDash)

            scenarioSVG
                .append("path")
                .attr("fill", "none")
                .attr("stroke-width", "3px")
                .attr("class", "forecast")
                .transition().delay(7500)
                .attr("d", function (d) {
                    return d3.line()//area
                        .x(function (d) { return x(dateParser(d.TIME)); })
                        // .y0(y(0))
                        .y(function (d) { return y(parseFloat(d.downsideScenario)); })
                        (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartForecast); }))
                })

                .on("end", drawUpsideScenario)
            
            document.getElementById('explainer').innerHTML = "But a stronger resurgence of the virus, or more stringent lockdowns could strongly impact global growth in 2021.";
            

        }

        function drawUpsideScenario() {

            scenarioSVG
                .append("path")
                .attr("fill", "none")
                .attr("stroke", function (d) { return color[2] })
                .attr("stroke-width", "3px")
                .attr("d", function (d) {
                    return d3.line()//area
                        .x(function (d) { return x(dateParser(d.TIME)); })
                        // .y0(y(0))
                        .y(function (d) { return y(parseFloat(d.upsideScenario)); })
                        (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast2); }))
                })
                .transition()
                .duration(8000)
                .attrTween("stroke-dasharray", tweenDash)

            scenarioSVG
                .append("path")
                .attr("fill", "none")
                .attr("stroke-width", "3px")
                .attr("class", "forecast")
                .transition().delay(7500)
                .attr("d", function (d) {
                    return d3.line()//area
                        .x(function (d) { return x(dateParser(d.TIME)); })
                        // .y0(y(0))
                        .y(function (d) { return y(parseFloat(d.upsideScenario)); })
                        (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartForecast); }))
                })

                .on("end", annotate)

           

            document.getElementById('explainer').innerHTML = "If the threat from the virus fades more quickly than expected, improved consumer confidence could boost global activity sharply in 2021.";


        } 

        function annotate(){
            //make uncertainty area visible
             scenarioSVG.select("#uncertaintyArea")
                .attr("opacity", 0.2);

          // Features of the annotation
            const annotation2019 = [
                {
                    note: {
                        label: "November 2019 forecasts"
                    },
                    x: x(dateParser("2020-Q1")),
                    y: y(annotationMark2019[0].forecast2019),
                    dy: -25,
                    dx: -5
                }
            ]
            const annotationDown = [
                {
                    note: {
                        label: "Downside scenario"
                        
                    },
                    x: x(dateParser("2021-Q1")),
                    y: y(annotationMark[0].downsideScenario),
                    dy: 40,
                    dx: -50
                }
            ]
            const annotationUp = [
                {
                    note: {
                        label: "Upside scenarion"
                    },
                    x: x(dateParser("2021-Q1")),
                    y: y(annotationMark[0].upsideScenario),
                    dy: -10,
                    dx: -20
                }
            ]


            const annotationCurrent = [
                {
                    note: {
                        label: "Current forecasts"
                    },
                    x: x(dateParser("2021-Q1")),
                    y: y(annotationMark[0].currentProjection),
                    dy: 10,
                    dx: 20
                }
            ]
            // Add annotation to the chart
            const makeAnnotation2019 = d3.annotation()
                .annotations(annotation2019)
            scenarioSVG
                .append("g")
                .attr("class", "labelLine")
                .call(makeAnnotation2019)

            // Add annotation to the chart
            const makeAnnotationDown = d3.annotation()
                .annotations(annotationDown)
            scenarioSVG
                .append("g")
                .attr("class", "labelLine")
                .call(makeAnnotationDown)

            // Add annotation to the chart
            const makeAnnotationUp = d3.annotation()
                .annotations(annotationUp)
            scenarioSVG
                .append("g")
                .attr("class", "labelLine")
                .call(makeAnnotationUp)


            // Add annotation to the chart
            const makeAnnotationCurrent = d3.annotation()
                .annotations(annotationCurrent)
            scenarioSVG
                .append("g")
                .attr("class", "labelLine")
                .call(makeAnnotationCurrent)

            //adding uncertainty note
            const annotationUncertainty = [
                {
                    note: {
                        label: "Uncertainty area"
                    },
                    x: x(dateParser("2021-Q4")),
                    y: y((parseFloat(annotationMark[0].upsideScenario) + parseFloat(annotationMark[0].downsideScenario)) / 1.975),
                    dy: 100,
                    dx: -0.5
                }
            ]

            // Add annotation to the chart

         /*   const makeAnnotationUncertainty = d3.annotation()
                .annotations(annotationUncertainty)
            scenarioSVG
                .append("g")
                .attr("class", "labelLine")
                .call(makeAnnotationUncertainty)*/


            // Add you are here line
            const annotationPosition = [{
                note: {
                    label: "We are here",
                },
                type: d3.annotationCalloutCircle,
                subject: { radius: 10 },
                x: x(dateParser("2020-Q3")), y: y(annotationMarkPosition[0].currentProjection),
                dx: -15
            }]

            const makeAnnotationPosition = d3.annotation()
                .annotations(annotationPosition)
            scenarioSVG
                .append("g")
                .attr("class", "labelLine")
                .call(makeAnnotationPosition)

             document.getElementById('explainer').innerHTML = "";
            

            document.getElementById("player").style.display = "inline-block";

        }
    }

    d3.select("#player").on("click", updateChart)

    d3.select("#Share").on("click", function () {
        document.getElementById("shareLink").style.display = "inline-block";
    })
    d3.select("#shuttershare")
        .on("mouseover", function () {
            d3.select(this).style("opacity", 0.5);
        })
        .on("mouseout", function () {
            d3.select(this).style("opacity", 1);
        })
        .on("click", function () {
            document.getElementById("shareLink").style.display = 'none';
        })

    var switchStatus = false;
 
    $("#switchID").on('change', function () {
        if ($(this).is(':checked')) {
            switchStatus = $(this).is(':checked');
            whiteframe()
            drawsingleHit()
            drawdoubleHit()
        }
        else {
            switchStatus = $(this).is(':checked');
            removelines()
        }
    });

    function whiteframe(){


        scenarioSVG
            .append("rect")
            .attr("class", "oldforecast")
            .attrs({ x: 0, y: 0, width: width, height: height, fill: '#dce2e7' })
            .attr("opacity",0.8)

        scenarioSVG
            .append("path")
            .attr("fill", "none"/*"#8DCD79"*/)
            .attr("stroke", function (d) { return color[0] })
            .attr("stroke-width", "5px")
            // .attr("opacity", function () { if (k == 0) return 0.1; else return 1; })
            .attr("class", "lineContext oldforecast")
            //.attr("id", function (d) { return "doubleHit" + i; })
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.forecast2019)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) <= dateParser(startForecast); }))
            }).transition()
            .duration(0).attrTween("stroke-dasharray", tweenDash)

        scenarioSVG
            .append("path")
            .attr("class", "oldforecast")
            .attr("fill", "none")
            .attr("stroke", function (d) { return color[0] })
            .attr("stroke-width", "5px")
            .attr("opacity", 0.5)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.forecast2019)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
            })
            .transition()
            .duration(0)
            .attrTween("stroke-dasharray", tweenDash)

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke-width", "5px")
            .attr("class", "forecast oldforecast")
            .transition().delay(0)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.forecast2019)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
            })

        const annotation2019 = [
            {
                note: {
                    label: "November 2019 forecasts"
                },
                x: x(dateParser("2020-Q1")),
                y: y(annotationMark2019[0].forecast2019),
                dy: -25,
                dx: -5
            }
        ]

        // Add annotation to the chart
        const makeAnnotation2019 = d3.annotation()
            .annotations(annotation2019)
        scenarioSVG
            .append("g")
            .attr("class", "oldforecast")
            .call(makeAnnotation2019)

        d3.selectAll(".labelLine")
            .attr("opacity", 0)
    }

    function drawsingleHit() {
        
        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke", function (d) { return color[4] })
            .attr("stroke-width", "3px")
            .attr("class", "oldforecast")
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.singleHit)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
            })
            .transition()
            .duration(0)
            .attrTween("stroke-dasharray", tweenDash)

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke-width", "3px")
            .attr("class", "oldforecast oldforecastdashed")
            .transition().delay(0)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.singleHit)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartpreviousForecast); }))
            })


                
        const annotationSingle = [
            {
                note: {
                    label: "Single-hit scenario"
                },
                x: x(dateParser("2021-Q1")),
                y: y(annotationMark[0].singleHit),
                dy: -10,
                dx: -10
            }
        ]
        // Add annotation to the chart
        const makeAnnotationSingle = d3.annotation()
            .annotations(annotationSingle)
        scenarioSVG
            .append("g")
            .attr("class", "oldforecast")
            .call(makeAnnotationSingle)    

    } 

    function drawdoubleHit() {

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke", function (d) { return color[3] })
            .attr("stroke-width", "3px")
            .attr("class", "oldforecast")
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.doubleHit)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
            })
            .transition()
            .duration(0)
            .attrTween("stroke-dasharray", tweenDash)

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke-width", "3px")
            .attr("class", "oldforecast oldforecastdashed")
            .transition().delay(0)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.doubleHit)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartpreviousForecast); }))
            })


         const annotationDouble = [
            {
                note: {
                    label: "Double-hit scenario"
                },
                x: x(dateParser("2021-Q1")),
                y: y(annotationMark[0].doubleHit),
                dy: 20,
                dx: 10
            }
        ]
        // Add annotation to the chart
        const makeAnnotationDouble = d3.annotation()
            .annotations(annotationDouble)

        scenarioSVG
            .append("g")
            .attr("class", "oldforecast")
            .call(makeAnnotationDouble)    
    } 

    function removelines(){
    scenarioSVG.selectAll('.oldforecast').remove();


    d3.selectAll(".labelLine")
        .attr("opacity", 1)
}

    function renderChart() {

        x.domain(d3.extent(allScenario, function (d) { return dateParser(d.TIME); }))
        y.domain([d3.min(allScenario, function (d) { return d3.min([parseFloat(d.forecast2019), parseFloat(d.singleHit), parseFloat(d.doubleHit), parseFloat(d.currentScenario), parseFloat(d.upsideScenario), parseFloat(d.downsideScenario)]); }), d3.max(allScenario, function (d) { return d3.max([parseFloat(d.forecast2019), parseFloat(d.singleHit), parseFloat(d.doubleHit), parseFloat(d.currentScenario), parseFloat(d.upsideScenario), parseFloat(d.downsideScenario)]); })])



        scenarioSVG
            .append("g")
            .attr("class", "axisContext")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x).ticks(6)
                .tickFormat(function (x) {
                    // get the milliseconds since Epoch for the date
                    var milli = (x + 7884000000);

                    // calculate new date 10 seconds earlier. Could be one second, 
                    // but I like a little buffer for my neuroses
                    var vanilli = new Date(milli);

                    // calculate the month (0-11) based on the new date
                    var mon = vanilli.getMonth();
                    var yr = vanilli.getFullYear();

                    // return appropriate quarter for that month
                    if (mon <= 2) {
                        return yr + "-Q1";
                    } else if (mon <= 5) {
                        return yr + "-Q2";
                    } else if (mon <= 8) {
                        return yr + "-Q3";
                    } else {
                        return yr + "-Q4";
                    }
                }));

        scenarioSVG.append("g")
            .attr("class", "axisContext")
            .call(d3.axisLeft(y).tickFormat(function (d) {
                return y.tickFormat(10, d3.format(".0f"))(d)
            }).tickSize(-(width)));

        // Draw the line
        scenarioSVG
            .append("path")
            .attr("fill", "none"/*"#8DCD79"*/)
            .attr("stroke", function (d) { return color[0] })
            .attr("stroke-width", "5px")
            // .attr("opacity", function () { if (k == 0) return 0.1; else return 1; })
            .attr("class", "lineContext")
            //.attr("id", function (d) { return "doubleHit" + i; })
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.forecast2019)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) <= dateParser(startForecast); }))
            })
            .transition()
            .duration(0)
            .attrTween("stroke-dasharray", tweenDash)

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke", function (d) { return color[0] })
            .attr("stroke-width", "5px")
            .attr("opacity", 0.5)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.forecast2019)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
            })
            .transition()
            .duration(0)
            .attrTween("stroke-dasharray", tweenDash)


      /*  scenarioSVG
            .append("path")
            .attr("class", "forecast")
            .attr("id", "uncertaintyArea")
            .attr("fill", color[2])
            .attr("stroke-width", "0px")
            .attr("opacity", 0.2)
            .attr("d", function (d) {
                return d3.area()
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    .y0(function (d) { return y(parseFloat(d.downsideScenario)); })
                    .y1(function (d) { return y(parseFloat(d.upsideScenario)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartForecast); }))
            })*/
        
        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke-width", "5px")
            .attr("class", "forecast")
            .transition().delay(0)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.forecast2019)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
            })

        /*scenarioSVG
            .append("path")
            .attr("class", "forecast")
            .attr("id", "uncertaintyArea")
            .attr("fill", color[2])
            .attr("stroke-width", "0px")
            .attr("opacity", 0)
            .attr("d", function (d) {
                return d3.area()
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    .y0(function (d) { return y(parseFloat(d.downsideScenario)); })
                    .y1(function (d) { return y(parseFloat(d.upsideScenario)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartForecast); }))
            })*/

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke", function (d) { return color[1] })
            .attr("stroke-width", "5px")
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.currentProjection)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast); }))
            })
            .transition()
            .duration(0)
            .attrTween("stroke-dasharray", tweenDash)

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke-width", "5px")
            .attr("class", "forecast")
            .transition().delay(0)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.currentProjection)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartForecast); }))
            })
        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke", function (d) { return color[2] })
            .attr("stroke-width", "3px")
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.downsideScenario)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast2); }))
            })
            .transition()
            .duration(0)
            .attrTween("stroke-dasharray", tweenDash)

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke-width", "3px")
            .attr("class", "forecast")
            .transition().delay(0)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.downsideScenario)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartForecast); }))
            })

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke", function (d) { return color[2] })
            .attr("stroke-width", "3px")
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.upsideScenario)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(startForecast2); }))
            })
            .transition()
            .duration(0)
            .attrTween("stroke-dasharray", tweenDash)

        scenarioSVG
            .append("path")
            .attr("fill", "none")
            .attr("stroke-width", "3px")
            .attr("class", "forecast")
            .transition().delay(0)
            .attr("d", function (d) {
                return d3.line()//area
                    .x(function (d) { return x(dateParser(d.TIME)); })
                    // .y0(y(0))
                    .y(function (d) { return y(parseFloat(d.upsideScenario)); })
                    (allScenario.filter(function (d) { return dateParser(d.TIME) >= dateParser(dashedStartForecast); }))
            })


        // Features of the annotation
        const annotation2019 = [
            {
                note: {
                    label: "November 2019 forecasts"
                },
                x: x(dateParser("2020-Q1")),
                y: y(annotationMark2019[0].forecast2019),
                dy: -25,
                dx: -5
            }
        ]
        const annotationDown = [
            {
                note: {
                    label: "Downside scenario"

                },
                x: x(dateParser("2021-Q1")),
                y: y(annotationMark[0].downsideScenario),
                dy: 40,
                dx: -50
            }
        ]
        const annotationUp = [
            {
                note: {
                    label: "Upside scenario"
                },
                x: x(dateParser("2021-Q1")),
                y: y(annotationMark[0].upsideScenario),
                dy: -10,
                dx: -20
            }
        ]


        const annotationCurrent = [
            {
                note: {
                    label: "Current forecasts"
                },
                x: x(dateParser("2021-Q1")),
                y: y(annotationMark[0].currentProjection),
                dy: 10,
                dx: 20
            }
        ]




        // Add annotation to the chart
        const makeAnnotation2019 = d3.annotation()
            .annotations(annotation2019)
        scenarioSVG
            .append("g")
            .attr("class", "labelLine")
            .call(makeAnnotation2019)

        // Add annotation to the chart
        const makeAnnotationDown = d3.annotation()
            .annotations(annotationDown)
        scenarioSVG
            .append("g")
            .attr("class", "labelLine")
            .call(makeAnnotationDown)

        // Add annotation to the chart
        const makeAnnotationUp = d3.annotation()
            .annotations(annotationUp)
        scenarioSVG
            .append("g")
            .attr("class", "labelLine")
            .call(makeAnnotationUp)


        // Add annotation to the chart
        const makeAnnotationCurrent = d3.annotation()
            .annotations(annotationCurrent)
        scenarioSVG
            .append("g")
            .attr("class", "labelLine")
            .call(makeAnnotationCurrent)
        //adding uncertainty note
        const annotationUncertainty = [
            {
                note: {
                    label: "Uncertainty area"
                },
                x: x(dateParser("2021-Q4")),
                y: y((parseFloat(annotationMark[0].upsideScenario) + parseFloat(annotationMark[0].downsideScenario)) / 1.975),
                dy: 100,
                dx: -0.5
            }
        ]

        // Add annotation to the chart
        /*  const makeAnnotationUncertainty = d3.annotation()
            .annotations(annotationUncertainty)
        scenarioSVG
            .append("g")
            .attr("class", "labelLine")
            .call(makeAnnotationUncertainty)*/

        // Add you are here line
        const annotationPosition = [{
                note: {
                    label: "We are here",
                },
                type: d3.annotationCalloutCircle,
                subject: { radius: 10 },
                x: x(dateParser("2020-Q3")), y: y(annotationMarkPosition[0].currentProjection) ,
                dx: -15
            }]

        const makeAnnotationPosition = d3.annotation()
            .annotations(annotationPosition)
        scenarioSVG
            .append("g")
            .attr("class", "labelLine")
            .call(makeAnnotationPosition)

    }



 </script>

</body>
